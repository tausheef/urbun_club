// controllers/docketController.js
import Docket from "../models/Docket.js";
import BookingInfo from "../models/BookingInfo.js";
import Invoice from "../models/Invoice.js";
import Consignor from "../models/Consignor.js";
import Consignee from "../models/Consignee.js";
import DocketCounter from "../models/DocketCounter.js";
import { createBookedActivity } from "./ActivityController.js";
import { calculateDistance, calculateEwayBillValidity, calculateExpiryDate } from "../utils/Distancecalculator.js"; // ✅ NEW

// Helper function to parse DD/MM/YYYY format OR ISO date strings
const parseDate = (dateString) => {
  if (!dateString) return null;
  
  // Check if it's already a valid ISO date string (from frontend)
  if (typeof dateString === 'string' && dateString.includes('T')) {
    const date = new Date(dateString);
    return isNaN(date.getTime()) ? null : date;
  }
  
  // Handle DD/MM/YYYY format (legacy support)
  if (typeof dateString === 'string' && dateString.includes('/')) {
    const [day, month, year] = dateString.split('/');
    if (!day || !month || !year) return null;
    const date = new Date(`${year}-${month}-${day}`);
    return isNaN(date.getTime()) ? null : date;
  }
  
  // Try parsing as a regular date string
  const date = new Date(dateString);
  return isNaN(date.getTime()) ? null : date;
};

// ✅ NEW: Get next auto-generated docket number
export const getNextDocketNumber = async (req, res) => {
  try {
    // Find or create the counter
    let counter = await DocketCounter.findById("auto-docket-counter");
    
    if (!counter) {
      // Create initial counter if it doesn't exist
      counter = new DocketCounter({
        _id: "auto-docket-counter",
        lastNumber: 53220,  // Will start from 53221
        prefix: "05"
      });
      await counter.save();
    }

    // Calculate next number
    const nextNumber = counter.lastNumber + 1;
    const nextDocketNo = `${counter.prefix}${nextNumber}`;

    res.status(200).json({
      success: true,
      data: {
        nextDocketNo: nextDocketNo,
        isAutoGenerated: true
      }
    });
  } catch (error) {
    console.error("Error getting next docket number:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to get next docket number",
    });
  }
};

export const createDocketWithDetails = async (req, res) => {
  try {
    const {
      // Docket fields
      docketNo,
      bookingDate,
      destinationCity,
      location,
      postalCode,
      expectedDelivery,
      isAutoGenerated, // ✅ NEW: Flag to track if auto-generated
      
      // BookingInfo fields
      customerType,
      bookingMode,
      origin,
      originCity,
      originLocation,
      destinationBranch,
      billingParty,
      billingAt,
      bookingType,
      direction,
      deliveryMode,
      loadType,
      gstinNo,
      
      // Invoice fields
      eWayBill,
      invNo,
      invDate,
      partNo,
      itemDesc,
      weight,
      packet,
      netInvValue,
      gInvValue,
      
      // Consignor fields
      isTemporaryConsignor,
      consignor,
      consignorAddress,
      consignorCity,
      consignorState,
      consignorPin,
      consignorPhone,
      crgstinNo,
      
      // Consignee fields
      isTemporaryConsignee,
      consignee,
      consigneeAddress,
      consigneeCity,
      consigneeState,
      consigneePin,
      consigneePhone,
      cegstinNo,
      
      // Dimensions array
      dimensions,
    } = req.body;

    // ✅ NEW: Update counter ONLY if this is an auto-generated docket
    if (isAutoGenerated) {
      const counter = await DocketCounter.findById("auto-docket-counter");
      
      if (counter) {
        // Extract number from docket number (remove prefix "05" only)
        // Example: "053221" → remove "05" → "3221" → parseInt → 3221
        const docketNumber = parseInt(docketNo.substring(2)); // Remove first 2 characters (prefix "05")
        
        // Update counter to this number
        counter.lastNumber = docketNumber;
        counter.updatedAt = new Date();
        await counter.save();
      }
    }

    // 1. Create Consignor
    let consignorId = null;
    if (consignor) {
      const consignorData = new Consignor({
        isTemporary: isTemporaryConsignor || false,
        consignorName: consignor,
        address: consignorAddress,
        city: consignorCity,
        pin: consignorPin,
        state: consignorState,
        phone: consignorPhone,
        crgstinNo: crgstinNo,
      });
      const savedConsignor = await consignorData.save();
      consignorId = savedConsignor._id;
    }

    // 2. Create Consignee
    let consigneeId = null;
    if (consignee) {
      const consigneeData = new Consignee({
        isTemporary: isTemporaryConsignee || false,
        consigneeName: consignee,
        address: consigneeAddress,
        city: consigneeCity,
        pin: consigneePin,
        state: consigneeState,
        phone: consigneePhone,
        cegstinNo: cegstinNo,
      });
      const savedConsignee = await consigneeData.save();
      consigneeId = savedConsignee._id;
    }

    // Process dimensions array
    const processedDimensions = Array.isArray(dimensions) 
      ? dimensions.map(dim => ({
          length: parseFloat(dim.length) || 0,
          width: parseFloat(dim.width) || 0,
          height: parseFloat(dim.height) || 0,
          noOfPackets: parseFloat(dim.noOfPackets) || 0,
        }))
      : [];

    // ✅ NEW: Calculate distance between origin and destination
    let distance = 0;
    if (originCity && destinationCity) {
      distance = await calculateDistance(originCity, destinationCity);
      console.log(`Distance calculated: ${originCity} to ${destinationCity} = ${distance} km`);
    }

    // 3. Create Docket with Consignor, Consignee references and Dimensions array
    const docketData = new Docket({
      docketNo,
      bookingDate: parseDate(bookingDate),
      destinationCity,
      location,
      postalCode,
      expectedDelivery: parseDate(expectedDelivery),
      consignor: consignorId,
      consignee: consigneeId,
      dimensions: processedDimensions,
      isAutoGenerated: isAutoGenerated || false,
      distance: distance, // ✅ NEW: Store distance
    });

    const savedDocket = await docketData.save();

    // 4. Create BookingInfo
    const bookingInfoData = new BookingInfo({
      docketId: savedDocket._id,
      customerType,
      bookingMode,
      origin,
      originCity,
      originLocation,
      destinationBranch,
      billingParty,
      billingAt,
      bookingType,
      deliveryMode,
      loadType,
      gstinNo,
    });

    const savedBookingInfo = await bookingInfoData.save();

    // 5. Create Invoice
    let invoiceId = null;
    if (invNo) {
      // ✅ NEW: Calculate E-way Bill expiry date (if eWayBill exists)
      let eWayBillExpiry = null;
      if (eWayBill && distance > 0) {
        const validityDays = calculateEwayBillValidity(distance);
        eWayBillExpiry = calculateExpiryDate(savedDocket.createdAt, validityDays);
        console.log(`E-way Bill Expiry: ${eWayBillExpiry} (${validityDays} days validity for ${distance} km)`);
      }

      const invoiceData = new Invoice({
        eWayBill,
        invoiceNo: invNo,
        invoiceDate: parseDate(invDate),
        partNo,
        itemDescription: itemDesc,
        weight: parseFloat(weight) || 0,
        packet: parseFloat(packet) || 0,
        netInvoiceValue: parseFloat(netInvValue) || 0,
        grossInvoiceValue: parseFloat(gInvValue) || 0,
        docket: savedDocket._id,
        bookingInfo: savedBookingInfo._id,
        consignor: consignorId,
        consignee: consigneeId,
        eWayBillExpiry: eWayBillExpiry, // ✅ NEW: Store expiry date
      });

      const savedInvoice = await invoiceData.save();
      invoiceId = savedInvoice._id;
    }

    // ✅ NEW: Auto-create "Booked" activity
    await createBookedActivity(
      savedDocket._id,
      originCity || "Unknown",
      savedDocket.createdAt
    );

    res.status(201).json({
      success: true,
      message: "Docket created successfully with all details",
      data: {
        docket: savedDocket,
        bookingInfo: savedBookingInfo,
        consignor: consignorId,
        consignee: consigneeId,
        invoice: invoiceId,
      },
    });
  } catch (error) {
    console.error("Error creating docket:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to create docket",
    });
  }
};

export const getDocketWithDetails = async (req, res) => {
  try {
    const { docketId } = req.params;

    // Populate consignor and consignee
    const docket = await Docket.findById(docketId)
      .populate("consignor")
      .populate("consignee");

    if (!docket) {
      return res.status(404).json({
        success: false,
        message: "Docket not found",
      });
    }

    const bookingInfo = await BookingInfo.findOne({ docketId });
    const invoice = await Invoice.findOne({ docket: docketId })
      .populate("consignor")
      .populate("consignee");

    res.status(200).json({
      success: true,
      data: {
        docket,
        bookingInfo,
        invoice,
      },
    });
  } catch (error) {
    console.error("Error fetching docket:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to fetch docket",
    });
  }
};

export const getAllDockets = async (req, res) => {
  try {
    // IMPORTANT: Populate consignor and consignee from Docket
    const dockets = await Docket.find()
      .populate("consignor")
      .populate("consignee");

    const docketsWithDetails = await Promise.all(
      dockets.map(async (docket) => {
        const bookingInfo = await BookingInfo.findOne({ docketId: docket._id });
        const invoice = await Invoice.findOne({ docket: docket._id })
          .populate("consignor")
          .populate("consignee");

        return {
          docket,
          bookingInfo,
          invoice,
        };
      })
    );

    res.status(200).json({
      success: true,
      data: docketsWithDetails,
    });
  } catch (error) {
    console.error("Error fetching dockets:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to fetch dockets",
    });
  }
};

export const updateDocketWithDetails = async (req, res) => {
  try {
    const { docketId } = req.params;
    const updateData = req.body;

    // Update Docket
    const docketUpdates = {};
    if (updateData.docketNo !== undefined) docketUpdates.docketNo = updateData.docketNo;
    if (updateData.bookingDate !== undefined) docketUpdates.bookingDate = parseDate(updateData.bookingDate);
    if (updateData.destinationCity !== undefined) docketUpdates.destinationCity = updateData.destinationCity;
    if (updateData.location !== undefined) docketUpdates.location = updateData.location;
    if (updateData.postalCode !== undefined) docketUpdates.postalCode = updateData.postalCode;
    if (updateData.expectedDelivery !== undefined) docketUpdates.expectedDelivery = parseDate(updateData.expectedDelivery);

    // Handle dimensions array
    if (updateData.dimensions && Array.isArray(updateData.dimensions)) {
      docketUpdates.dimensions = updateData.dimensions.map(dim => ({
        length: parseFloat(dim.length) || 0,
        width: parseFloat(dim.width) || 0,
        height: parseFloat(dim.height) || 0,
        noOfPackets: parseFloat(dim.noOfPackets) || 0,
      }));
    }

    // Populate consignor and consignee
    const updatedDocket = await Docket.findByIdAndUpdate(docketId, docketUpdates, { new: true })
      .populate("consignor")
      .populate("consignee");

    // Update BookingInfo
    const bookingUpdates = {};
    if (updateData.customerType !== undefined) bookingUpdates.customerType = updateData.customerType;
    if (updateData.bookingMode !== undefined) bookingUpdates.bookingMode = updateData.bookingMode;
    if (updateData.origin !== undefined) bookingUpdates.origin = updateData.origin;
    if (updateData.originCity !== undefined) bookingUpdates.originCity = updateData.originCity;
    if (updateData.originLocation !== undefined) bookingUpdates.originLocation = updateData.originLocation;
    if (updateData.destinationBranch !== undefined) bookingUpdates.destinationBranch = updateData.destinationBranch;
    if (updateData.billingParty !== undefined) bookingUpdates.billingParty = updateData.billingParty;
    if (updateData.billingAt !== undefined) bookingUpdates.billingAt = updateData.billingAt;
    if (updateData.bookingType !== undefined) bookingUpdates.bookingType = updateData.bookingType;
    if (updateData.deliveryMode !== undefined) bookingUpdates.deliveryMode = updateData.deliveryMode;
    if (updateData.loadType !== undefined) bookingUpdates.loadType = updateData.loadType;
    if (updateData.gstinNo !== undefined) bookingUpdates.gstinNo = updateData.gstinNo;

    const updatedBookingInfo = await BookingInfo.findOneAndUpdate(
      { docketId },
      bookingUpdates,
      { new: true }
    );
    
    // ================= UPDATE CONSIGNOR =================
    if (updatedDocket?.consignor?._id) {
      await Consignor.findByIdAndUpdate(
        updatedDocket.consignor._id,
        {
          isTemporary: updateData.isTemporaryConsignor,
          consignorName: updateData.consignor,
          address: updateData.consignorAddress,
          city: updateData.consignorCity,
          state: updateData.consignorState,
          pin: updateData.consignorPin,
          phone: updateData.consignorPhone,
          crgstinNo: updateData.crgstinNo,
        }
      );
    }

    // ================= UPDATE CONSIGNEE =================
    if (updatedDocket?.consignee?._id) {
      await Consignee.findByIdAndUpdate(
        updatedDocket.consignee._id,
        {
          isTemporary: updateData.isTemporaryConsignee,
          consigneeName: updateData.consignee,
          address: updateData.consigneeAddress,
          city: updateData.consigneeCity,
          state: updateData.consigneeState,
          pin: updateData.consigneePin,
          phone: updateData.consigneePhone,
          cegstinNo: updateData.cegstinNo,
        }
      );
    }

    // Update Invoice if invoice data is provided
    let updatedInvoice = null;
    if (updateData.invNo) {
      const invoiceUpdates = {};
      if (updateData.eWayBill !== undefined) invoiceUpdates.eWayBill = updateData.eWayBill;
      if (updateData.invNo !== undefined) invoiceUpdates.invoiceNo = updateData.invNo;
      if (updateData.invDate !== undefined) invoiceUpdates.invoiceDate = parseDate(updateData.invDate);
      if (updateData.partNo !== undefined) invoiceUpdates.partNo = updateData.partNo;
      if (updateData.itemDesc !== undefined) invoiceUpdates.itemDescription = updateData.itemDesc;
      if (updateData.weight !== undefined) invoiceUpdates.weight = parseFloat(updateData.weight);
      if (updateData.packet !== undefined) invoiceUpdates.packet = parseFloat(updateData.packet);
      if (updateData.netInvValue !== undefined) invoiceUpdates.netInvoiceValue = parseFloat(updateData.netInvValue);
      if (updateData.gInvValue !== undefined) invoiceUpdates.grossInvoiceValue = parseFloat(updateData.gInvValue);

      updatedInvoice = await Invoice.findOneAndUpdate(
        { docket: docketId },
        invoiceUpdates,
        { new: true }
      );
    }

    res.status(200).json({
      success: true,
      message: "Docket updated successfully",
      data: {
        docket: updatedDocket,
        bookingInfo: updatedBookingInfo,
        invoice: updatedInvoice,
      },
    });
  } catch (error) {
    console.error("Error updating docket:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to update docket",
    });
  }
};

export const deleteDocketWithDetails = async (req, res) => {
  try {
    const { docketId } = req.params;

    // Delete related documents
    await BookingInfo.deleteMany({ docketId });
    await Invoice.deleteMany({ docket: docketId });
    await Docket.findByIdAndDelete(docketId);

    res.status(200).json({
      success: true,
      message: "Docket and related details deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting docket:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to delete docket",
    });
  }
};

// ✅ Toggle RTO (Return to Origin) status for a docket
export const toggleRto = async (req, res) => {
  try {
    const { id } = req.params;
    const { rto } = req.body;

    // ✅ Use findByIdAndUpdate to update only RTO field without triggering full validation
    const docket = await Docket.findByIdAndUpdate(
      id,
      { rto: rto },
      { new: true, runValidators: false } // new: true returns updated doc, runValidators: false skips validation
    );

    if (!docket) {
      return res.status(404).json({
        success: false,
        message: "Docket not found",
      });
    }

    res.status(200).json({
      success: true,
      message: `RTO ${rto ? 'enabled' : 'disabled'} successfully`,
      data: {
        docketId: docket._id,
        docketNo: docket.docketNo,
        rto: docket.rto,
      },
    });
  } catch (error) {
    console.error("Error toggling RTO:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to toggle RTO",
    });
  }
};
// ========================================================================
// ✅ NEW: Status-Based Filtering Functions
// ========================================================================

/**
 * @desc    Get all delivered dockets
 * @route   GET /api/v1/dockets/delivered
 * @access  Public
 */
export const getDeliveredDockets = async (req, res) => {
  try {
    // Import Activity model (ensure it's imported at the top)
    const Activity = (await import("../models/Activity.js")).default;
    
    // Get all active (non-cancelled) dockets
    const dockets = await Docket.find({ docketStatus: 'Active' })
      .populate("consignor")
      .populate("consignee")
      .lean();

    // Get all activities
    const activities = await Activity.find()
      .sort({ date: -1, time: -1 })
      .lean();

    // Group activities by docketId
    const activitiesByDocket = {};
    activities.forEach((activity) => {
      const docketId = activity.docketId.toString();
      if (!activitiesByDocket[docketId]) {
        activitiesByDocket[docketId] = [];
      }
      activitiesByDocket[docketId].push(activity);
    });

    // Filter and format delivered dockets
    const deliveredDockets = [];
    
    for (const docket of dockets) {
      const docketActivities = activitiesByDocket[docket._id.toString()] || [];
      
      if (docketActivities.length > 0) {
        // Get latest activity (already sorted)
        const latestActivity = docketActivities[0];
        const status = latestActivity.status.toLowerCase().trim();
        
        // Check if delivered (handles "Delivered", "(RTO) Delivered", etc.)
        // But exclude "Undelivered"
        if (status.includes("delivered") && !status.includes("undelivered")) {
          deliveredDockets.push({
            docket: {
              _id: docket._id,
              docketNo: docket.docketNo,
              bookingDate: docket.bookingDate,
              expectedDeliveryDate: docket.expectedDelivery,
              destinationCity: docket.destinationCity,
              consignor: docket.consignor,
              consignee: docket.consignee,
              rto: docket.rto,
            },
            bookingInfo: {
              originCity: docket.location || docket.destinationCity,
            },
            activities: docketActivities,
          });
        }
      }
    }

    res.status(200).json({
      success: true,
      count: deliveredDockets.length,
      data: deliveredDockets,
    });
  } catch (error) {
    console.error("❌ Error fetching delivered dockets:", error);
    res.status(500).json({
      success: false,
      message: "Error fetching delivered dockets",
      error: error.message,
    });
  }
};

/**
 * @desc    Get all undelivered dockets
 * @route   GET /api/v1/dockets/undelivered
 * @access  Public
 */
export const getUndeliveredDockets = async (req, res) => {
  try {
    const Activity = (await import("../models/Activity.js")).default;
    
    const dockets = await Docket.find({ docketStatus: 'Active' })
      .populate("consignor")
      .populate("consignee")
      .lean();

    const activities = await Activity.find()
      .sort({ date: -1, time: -1 })
      .lean();

    const activitiesByDocket = {};
    activities.forEach((activity) => {
      const docketId = activity.docketId.toString();
      if (!activitiesByDocket[docketId]) {
        activitiesByDocket[docketId] = [];
      }
      activitiesByDocket[docketId].push(activity);
    });

    const undeliveredDockets = [];
    
    for (const docket of dockets) {
      const docketActivities = activitiesByDocket[docket._id.toString()] || [];
      
      if (docketActivities.length > 0) {
        const latestActivity = docketActivities[0];
        const status = latestActivity.status.toLowerCase().trim();
        
        // Check if status contains "undelivered"
        if (status.includes("undelivered")) {
          undeliveredDockets.push({
            docket: {
              _id: docket._id,
              docketNo: docket.docketNo,
              bookingDate: docket.bookingDate,
              expectedDeliveryDate: docket.expectedDelivery,
              destinationCity: docket.destinationCity,
              consignor: docket.consignor,
              consignee: docket.consignee,
              rto: docket.rto,
            },
            bookingInfo: {
              originCity: docket.location || docket.destinationCity,
            },
            activities: docketActivities,
          });
        }
      }
    }

    res.status(200).json({
      success: true,
      count: undeliveredDockets.length,
      data: undeliveredDockets,
    });
  } catch (error) {
    console.error("❌ Error fetching undelivered dockets:", error);
    res.status(500).json({
      success: false,
      message: "Error fetching undelivered dockets",
      error: error.message,
    });
  }
};

/**
 * @desc    Get all pending dockets (not delivered or undelivered)
 * @route   GET /api/v1/dockets/pending
 * @access  Public
 */
export const getPendingDockets = async (req, res) => {
  try {
    const Activity = (await import("../models/Activity.js")).default;
    
    const dockets = await Docket.find({ docketStatus: 'Active' })
      .populate("consignor")
      .populate("consignee")
      .lean();

    const activities = await Activity.find()
      .sort({ date: -1, time: -1 })
      .lean();

    const activitiesByDocket = {};
    activities.forEach((activity) => {
      const docketId = activity.docketId.toString();
      if (!activitiesByDocket[docketId]) {
        activitiesByDocket[docketId] = [];
      }
      activitiesByDocket[docketId].push(activity);
    });

    const pendingDockets = [];
    
    for (const docket of dockets) {
      const docketActivities = activitiesByDocket[docket._id.toString()] || [];
      
      let isPending = false;
      
      if (docketActivities.length === 0) {
        // No activities = pending
        isPending = true;
      } else {
        const latestActivity = docketActivities[0];
        const status = latestActivity.status.toLowerCase().trim();
        
        // Pending if NOT delivered and NOT undelivered
        const isDelivered = status.includes("delivered") && !status.includes("undelivered");
        const isUndelivered = status.includes("undelivered");
        
        isPending = !isDelivered && !isUndelivered;
      }
      
      if (isPending) {
        pendingDockets.push({
          docket: {
            _id: docket._id,
            docketNo: docket.docketNo,
            bookingDate: docket.bookingDate,
            expectedDeliveryDate: docket.expectedDelivery,
            destinationCity: docket.destinationCity,
            consignor: docket.consignor,
            consignee: docket.consignee,
            rto: docket.rto,
          },
          bookingInfo: {
            originCity: docket.location || docket.destinationCity,
          },
          activities: docketActivities,
        });
      }
    }

    res.status(200).json({
      success: true,
      count: pendingDockets.length,
      data: pendingDockets,
    });
  } catch (error) {
    console.error("❌ Error fetching pending dockets:", error);
    res.status(500).json({
      success: false,
      message: "Error fetching pending dockets",
      error: error.message,
    });
  }
};

/**
 * @desc    Get all RTO (Return to Origin) dockets
 * @route   GET /api/v1/dockets/rto
 * @access  Public
 */
export const getRTODockets = async (req, res) => {
  try {
    const Activity = (await import("../models/Activity.js")).default;
    
    const dockets = await Docket.find({ docketStatus: 'Active' })
      .populate("consignor")
      .populate("consignee")
      .lean();

    const activities = await Activity.find()
      .sort({ date: -1, time: -1 })
      .lean();

    const activitiesByDocket = {};
    activities.forEach((activity) => {
      const docketId = activity.docketId.toString();
      if (!activitiesByDocket[docketId]) {
        activitiesByDocket[docketId] = [];
      }
      activitiesByDocket[docketId].push(activity);
    });

    const rtoDockets = [];
    
    for (const docket of dockets) {
      const docketActivities = activitiesByDocket[docket._id.toString()] || [];
      
      // Check if docket has RTO flag
      const hasRTOFlag = docket.rto === true;
      
      // Check if any activity has RTO in status
      let hasRTOActivity = false;
      if (docketActivities.length > 0) {
        // Check any activity, not just the latest
        hasRTOActivity = docketActivities.some(activity => {
          const status = activity.status.toLowerCase().trim();
          return status.includes("(rto)") || 
                 status.includes("rto") || 
                 status.includes("return to origin") ||
                 status.includes("return to sender");
        });
      }
      
      if (hasRTOFlag || hasRTOActivity) {
        rtoDockets.push({
          docket: {
            _id: docket._id,
            docketNo: docket.docketNo,
            bookingDate: docket.bookingDate,
            expectedDeliveryDate: docket.expectedDelivery,
            destinationCity: docket.destinationCity,
            consignor: docket.consignor,
            consignee: docket.consignee,
            rto: docket.rto,
          },
          bookingInfo: {
            originCity: docket.location || docket.destinationCity,
          },
          activities: docketActivities,
        });
      }
    }

    res.status(200).json({
      success: true,
      count: rtoDockets.length,
      data: rtoDockets,
    });
  } catch (error) {
    console.error("❌ Error fetching RTO dockets:", error);
    res.status(500).json({
      success: false,
      message: "Error fetching RTO dockets",
      error: error.message,
    });
  }
};